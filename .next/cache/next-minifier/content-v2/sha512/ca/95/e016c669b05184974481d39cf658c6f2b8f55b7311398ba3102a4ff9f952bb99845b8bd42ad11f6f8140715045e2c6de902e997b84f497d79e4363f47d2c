{"code":"(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[10],{\"6yEv\":function(e,t,r){\"use strict\";(function(e){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),f=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\"default\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)\"default\"!==r&&Object.hasOwnProperty.call(e,r)&&n(t,e,r);return f(t,e),t};Object.defineProperty(t,\"__esModule\",{value:!0}),t.rlphash=t.ripemd160FromArray=t.ripemd160FromString=t.ripemd160=t.sha256FromArray=t.sha256FromString=t.sha256=t.keccakFromArray=t.keccakFromHexString=t.keccakFromString=t.keccak256=t.keccak=void 0;const s=r(\"wzGL\"),u=r(\"mObS\"),o=i(r(\"o8pB\")),a=r(\"QMmI\"),c=r(\"RD56\");t.keccak=function(e,t=256){switch(c.assertIsBuffer(e),t){case 224:return s.keccak224(e);case 256:return s.keccak256(e);case 384:return s.keccak384(e);case 512:return s.keccak512(e);default:throw new Error(`Invald algorithm: keccak${t}`)}},t.keccak256=function(e){return t.keccak(e)},t.keccakFromString=function(r,n=256){c.assertIsString(r);const f=e.from(r,\"utf8\");return t.keccak(f,n)},t.keccakFromHexString=function(e,r=256){return c.assertIsHexString(e),t.keccak(a.toBuffer(e),r)},t.keccakFromArray=function(e,r=256){return c.assertIsArray(e),t.keccak(a.toBuffer(e),r)};const l=function(e){return e=a.toBuffer(e),u(\"sha256\").update(e).digest()};t.sha256=function(e){return c.assertIsBuffer(e),l(e)},t.sha256FromString=function(e){return c.assertIsString(e),l(e)},t.sha256FromArray=function(e){return c.assertIsArray(e),l(e)};const d=function(e,t){e=a.toBuffer(e);const r=u(\"rmd160\").update(e).digest();return!0===t?a.setLengthLeft(r,32):r};t.ripemd160=function(e,t){return c.assertIsBuffer(e),d(e,t)},t.ripemd160FromString=function(e,t){return c.assertIsString(e),d(e,t)},t.ripemd160FromArray=function(e,t){return c.assertIsArray(e),d(e,t)},t.rlphash=function(e){return t.keccak(o.encode(e))}}).call(this,r(\"HDXh\").Buffer)},BNs3:function(e,t,r){\"use strict\";(function(e){var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,\"__esModule\",{value:!0}),t.toType=t.TypeOutput=t.bnToRlp=t.bnToHex=void 0;const f=n(r(\"OZ/i\")),i=r(\"mhLr\"),s=r(\"QMmI\");var u;t.bnToHex=function(e){return`0x${e.toString(16)}`},t.bnToRlp=function(t){return s.unpadBuffer(t.toArrayLike(e))},function(e){e[e.Number=0]=\"Number\",e[e.BN=1]=\"BN\",e[e.Buffer=2]=\"Buffer\",e[e.PrefixedHexString=3]=\"PrefixedHexString\"}(u=t.TypeOutput||(t.TypeOutput={})),t.toType=function(e,t){if(\"string\"===typeof e&&!i.isHexString(e))throw new Error(`A string must be provided with a 0x-prefix, given: ${e}`);if(\"number\"===typeof e&&!Number.isSafeInteger(e))throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");if(e=s.toBuffer(e),t===u.Buffer)return e;if(t===u.BN)return new f.default(e);if(t===u.Number){const t=new f.default(e),r=new f.default(Number.MAX_SAFE_INTEGER.toString());if(t.gt(r))throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)\");return t.toNumber()}return`0x${e.toString(\"hex\")}`}}).call(this,r(\"HDXh\").Buffer)},L9Jt:function(e,t,r){\"use strict\";(function(e){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),f=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\"default\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)\"default\"!==r&&Object.hasOwnProperty.call(e,r)&&n(t,e,r);return f(t,e),t},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,\"__esModule\",{value:!0}),t.defineProperties=void 0;const u=s(r(\"7rlJ\")),o=i(r(\"mhLr\")),a=i(r(\"o8pB\")),c=r(\"QMmI\");t.defineProperties=function(t,r,n){if(t.raw=[],t._fields=[],t.toJSON=function(e=!1){if(e){const e={};return t._fields.forEach((r=>{e[r]=`0x${t[r].toString(\"hex\")}`})),e}return c.baToJSON(t.raw)},t.serialize=function(){return a.encode(t.raw)},r.forEach(((r,n)=>{function f(){return t.raw[n]}function i(f){\"00\"!==(f=c.toBuffer(f)).toString(\"hex\")||r.allowZero||(f=e.allocUnsafe(0)),r.allowLess&&r.length?(f=c.unpadBuffer(f),u.default(r.length>=f.length,`The field ${r.name} must not have more ${r.length} bytes`)):r.allowZero&&0===f.length||!r.length||u.default(r.length===f.length,`The field ${r.name} must have byte length of ${r.length}`),t.raw[n]=f}t._fields.push(r.name),Object.defineProperty(t,r.name,{enumerable:!0,configurable:!0,get:f,set:i}),r.default&&(t[r.name]=r.default),r.alias&&Object.defineProperty(t,r.alias,{enumerable:!1,configurable:!0,set:i,get:f})})),n)if(\"string\"===typeof n&&(n=e.from(o.stripHexPrefix(n),\"hex\")),e.isBuffer(n)&&(n=a.decode(n)),Array.isArray(n)){if(n.length>t._fields.length)throw new Error(\"wrong number of fields in data\");n.forEach(((e,r)=>{t[t._fields[r]]=c.toBuffer(e)}))}else{if(\"object\"!==typeof n)throw new Error(\"invalid data\");{const e=Object.keys(n);r.forEach((r=>{-1!==e.indexOf(r.name)&&(t[r.name]=n[r.name]),-1!==e.indexOf(r.alias)&&(t[r.alias]=n[r.alias])}))}}}}).call(this,r(\"HDXh\").Buffer)},QMmI:function(e,t,r){\"use strict\";(function(e){var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,\"__esModule\",{value:!0}),t.baToJSON=t.addHexPrefix=t.toUnsigned=t.fromSigned=t.bufferToHex=t.bufferToInt=t.toBuffer=t.unpadHexString=t.unpadArray=t.unpadBuffer=t.setLengthRight=t.setLengthLeft=t.zeros=void 0;const f=n(r(\"OZ/i\")),i=r(\"mhLr\"),s=r(\"RD56\");t.zeros=function(t){return e.allocUnsafe(t).fill(0)};const u=function(e,r,n){const f=t.zeros(r);return n?e.length<r?(e.copy(f),f):e.slice(0,r):e.length<r?(e.copy(f,r-e.length),f):e.slice(-r)};t.setLengthLeft=function(e,t){return s.assertIsBuffer(e),u(e,t,!1)},t.setLengthRight=function(e,t){return s.assertIsBuffer(e),u(e,t,!0)};const o=function(e){let t=e[0];for(;e.length>0&&\"0\"===t.toString();)t=(e=e.slice(1))[0];return e};t.unpadBuffer=function(e){return s.assertIsBuffer(e),o(e)},t.unpadArray=function(e){return s.assertIsArray(e),o(e)},t.unpadHexString=function(e){return s.assertIsHexString(e),e=i.stripHexPrefix(e),o(e)},t.toBuffer=function(t){if(null===t||void 0===t)return e.allocUnsafe(0);if(e.isBuffer(t))return e.from(t);if(Array.isArray(t)||t instanceof Uint8Array)return e.from(t);if(\"string\"===typeof t){if(!i.isHexString(t))throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${t}`);return e.from(i.padToEven(i.stripHexPrefix(t)),\"hex\")}if(\"number\"===typeof t)return i.intToBuffer(t);if(f.default.isBN(t))return t.toArrayLike(e);if(t.toArray)return e.from(t.toArray());if(t.toBuffer)return e.from(t.toBuffer());throw new Error(\"invalid type\")},t.bufferToInt=function(e){return new f.default(t.toBuffer(e)).toNumber()},t.bufferToHex=function(e){return\"0x\"+(e=t.toBuffer(e)).toString(\"hex\")},t.fromSigned=function(e){return new f.default(e).fromTwos(256)},t.toUnsigned=function(t){return e.from(t.toTwos(256).toArray())},t.addHexPrefix=function(e){return\"string\"!==typeof e||i.isHexPrefixed(e)?e:\"0x\"+e},t.baToJSON=function(r){if(e.isBuffer(r))return`0x${r.toString(\"hex\")}`;if(r instanceof Array){const e=[];for(let n=0;n<r.length;n++)e.push(t.baToJSON(r[n]));return e}}}).call(this,r(\"HDXh\").Buffer)},RD56:function(e,t,r){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.assertIsString=t.assertIsArray=t.assertIsBuffer=t.assertIsHexString=void 0;const n=r(\"mhLr\");t.assertIsHexString=function(e){if(!n.isHexString(e)){throw new Error(`This method only supports 0x-prefixed hex strings but input was: ${e}`)}},t.assertIsBuffer=function(t){if(!e.isBuffer(t)){throw new Error(`This method only supports Buffer but input was: ${t}`)}},t.assertIsArray=function(e){if(!Array.isArray(e)){throw new Error(`This method only supports number arrays but input was: ${e}`)}},t.assertIsString=function(e){if(\"string\"!==typeof e){throw new Error(`This method only supports strings but input was: ${e}`)}}}).call(this,r(\"HDXh\").Buffer)},cAFe:function(e,t,r){\"use strict\";(function(e){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),f=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\"default\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)\"default\"!==r&&Object.hasOwnProperty.call(e,r)&&n(t,e,r);return f(t,e),t},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,\"__esModule\",{value:!0}),t.isZeroAddress=t.zeroAddress=t.importPublic=t.privateToAddress=t.privateToPublic=t.publicToAddress=t.pubToAddress=t.isValidPublic=t.isValidPrivate=t.generateAddress2=t.generateAddress=t.isValidChecksumAddress=t.toChecksumAddress=t.isValidAddress=t.Account=void 0;const u=s(r(\"7rlJ\")),o=s(r(\"OZ/i\")),a=i(r(\"o8pB\")),c=r(\"IhPl\"),l=r(\"mhLr\"),d=r(\"ypah\"),h=r(\"QMmI\"),p=r(\"6yEv\"),g=r(\"RD56\"),b=r(\"BNs3\");class m{constructor(e=new o.default(0),t=new o.default(0),r=d.KECCAK256_RLP,n=d.KECCAK256_NULL){this.nonce=e,this.balance=t,this.stateRoot=r,this.codeHash=n,this._validate()}static fromAccountData(e){const{nonce:t,balance:r,stateRoot:n,codeHash:f}=e;return new m(t?new o.default(h.toBuffer(t)):void 0,r?new o.default(h.toBuffer(r)):void 0,n?h.toBuffer(n):void 0,f?h.toBuffer(f):void 0)}static fromRlpSerializedAccount(e){const t=a.decode(e);if(!Array.isArray(t))throw new Error(\"Invalid serialized account input. Must be array\");return this.fromValuesArray(t)}static fromValuesArray(e){const[t,r,n,f]=e;return new m(new o.default(t),new o.default(r),n,f)}_validate(){if(this.nonce.lt(new o.default(0)))throw new Error(\"nonce must be greater than zero\");if(this.balance.lt(new o.default(0)))throw new Error(\"balance must be greater than zero\");if(32!==this.stateRoot.length)throw new Error(\"stateRoot must have a length of 32\");if(32!==this.codeHash.length)throw new Error(\"codeHash must have a length of 32\")}raw(){return[b.bnToRlp(this.nonce),b.bnToRlp(this.balance),this.stateRoot,this.codeHash]}serialize(){return a.encode(this.raw())}isContract(){return!this.codeHash.equals(d.KECCAK256_NULL)}isEmpty(){return this.balance.isZero()&&this.nonce.isZero()&&this.codeHash.equals(d.KECCAK256_NULL)}}t.Account=m,t.isValidAddress=function(e){try{g.assertIsString(e)}catch(t){return!1}return/^0x[0-9a-fA-F]{40}$/.test(e)},t.toChecksumAddress=function(e,t){g.assertIsHexString(e);const r=l.stripHexPrefix(e).toLowerCase();let n=\"\";if(t){n=b.toType(t,b.TypeOutput.BN).toString()+\"0x\"}const f=p.keccakFromString(n+r).toString(\"hex\");let i=\"0x\";for(let s=0;s<r.length;s++)parseInt(f[s],16)>=8?i+=r[s].toUpperCase():i+=r[s];return i},t.isValidChecksumAddress=function(e,r){return t.isValidAddress(e)&&t.toChecksumAddress(e,r)===e},t.generateAddress=function(t,r){g.assertIsBuffer(t),g.assertIsBuffer(r);const n=new o.default(r);return n.isZero()?p.rlphash([t,null]).slice(-20):p.rlphash([t,e.from(n.toArray())]).slice(-20)},t.generateAddress2=function(t,r,n){g.assertIsBuffer(t),g.assertIsBuffer(r),g.assertIsBuffer(n),u.default(20===t.length),u.default(32===r.length);return p.keccak256(e.concat([e.from(\"ff\",\"hex\"),t,r,p.keccak256(n)])).slice(-20)},t.isValidPrivate=function(e){return c.privateKeyVerify(e)},t.isValidPublic=function(t,r=!1){return g.assertIsBuffer(t),64===t.length?c.publicKeyVerify(e.concat([e.from([4]),t])):!!r&&c.publicKeyVerify(t)},t.pubToAddress=function(t,r=!1){return g.assertIsBuffer(t),r&&64!==t.length&&(t=e.from(c.publicKeyConvert(t,!1).slice(1))),u.default(64===t.length),p.keccak(t).slice(-20)},t.publicToAddress=t.pubToAddress,t.privateToPublic=function(t){return g.assertIsBuffer(t),e.from(c.publicKeyCreate(t,!1)).slice(1)},t.privateToAddress=function(e){return t.publicToAddress(t.privateToPublic(e))},t.importPublic=function(t){return g.assertIsBuffer(t),64!==t.length&&(t=e.from(c.publicKeyConvert(t,!1).slice(1))),t},t.zeroAddress=function(){const e=h.zeros(20);return h.bufferToHex(e)},t.isZeroAddress=function(e){try{g.assertIsString(e)}catch(r){return!1}return t.zeroAddress()===e}}).call(this,r(\"HDXh\").Buffer)},g4Pk:function(e,t,r){\"use strict\";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),f=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\"default\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)\"default\"!==r&&Object.hasOwnProperty.call(e,r)&&n(t,e,r);return f(t,e),t},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,\"__esModule\",{value:!0}),t.rlp=t.BN=void 0;const u=s(r(\"OZ/i\"));t.BN=u.default;const o=i(r(\"o8pB\"));t.rlp=o},sboa:function(e,t,r){\"use strict\";(function(e){var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,\"__esModule\",{value:!0}),t.hashPersonalMessage=t.isValidSignature=t.fromRpcSig=t.toRpcSig=t.ecrecover=t.ecsign=void 0;const f=r(\"IhPl\"),i=n(r(\"OZ/i\")),s=r(\"QMmI\"),u=r(\"6yEv\"),o=r(\"RD56\"),a=r(\"BNs3\");function c(e,t){const r=a.toType(e,a.TypeOutput.BN);if(!t)return r.subn(27);const n=a.toType(t,a.TypeOutput.BN);return r.sub(n.muln(2).addn(35))}function l(e){const t=new i.default(e);return t.eqn(0)||t.eqn(1)}t.ecsign=function(t,r,n){const{signature:i,recid:s}=f.ecdsaSign(t,r),u=e.from(i.slice(0,32)),o=e.from(i.slice(32,64));if(!n||\"number\"===typeof n){if(n&&!Number.isSafeInteger(n))throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");return{r:u,s:o,v:n?s+(2*n+35):s+27}}return{r:u,s:o,v:a.toType(n,a.TypeOutput.BN).muln(2).addn(35).addn(s).toArrayLike(e)}},t.ecrecover=function(t,r,n,i,u){const o=e.concat([s.setLengthLeft(n,32),s.setLengthLeft(i,32)],64),a=c(r,u);if(!l(a))throw new Error(\"Invalid signature v value\");const d=f.ecdsaRecover(o,a.toNumber(),t);return e.from(f.publicKeyConvert(d,!1).slice(1))},t.toRpcSig=function(t,r,n,f){if(!l(c(t,f)))throw new Error(\"Invalid signature v value\");return s.bufferToHex(e.concat([s.setLengthLeft(r,32),s.setLengthLeft(n,32),s.toBuffer(t)]))},t.fromRpcSig=function(e){const t=s.toBuffer(e);if(t.length<65)throw new Error(\"Invalid signature length\");let r=s.bufferToInt(t.slice(64));return r<27&&(r+=27),{v:r,r:t.slice(0,32),s:t.slice(32,64)}},t.isValidSignature=function(e,t,r,n=!0,f){const s=new i.default(\"7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0\",16),u=new i.default(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\",16);if(32!==t.length||32!==r.length)return!1;if(!l(c(e,f)))return!1;const o=new i.default(t),a=new i.default(r);return!(o.isZero()||o.gt(u)||a.isZero()||a.gt(u))&&(!n||1!==a.cmp(s))},t.hashPersonalMessage=function(t){o.assertIsBuffer(t);const r=e.from(`\\x19Ethereum Signed Message:\\n${t.length.toString()}`,\"utf-8\");return u.keccak(e.concat([r,t]))}}).call(this,r(\"HDXh\").Buffer)},tnHP:function(e,t,r){\"use strict\";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),f=this&&this.__exportStar||function(e,t){for(var r in e)\"default\"===r||t.hasOwnProperty(r)||n(t,e,r)};Object.defineProperty(t,\"__esModule\",{value:!0}),f(r(\"ypah\"),t),f(r(\"cAFe\"),t),f(r(\"v0P2\"),t),f(r(\"6yEv\"),t),f(r(\"sboa\"),t),f(r(\"QMmI\"),t),f(r(\"L9Jt\"),t),f(r(\"g4Pk\"),t),f(r(\"BNs3\"),t),f(r(\"mhLr\"),t)},v0P2:function(e,t,r){\"use strict\";(function(e){var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,\"__esModule\",{value:!0}),t.Address=void 0;const f=n(r(\"7rlJ\")),i=n(r(\"OZ/i\")),s=r(\"QMmI\"),u=r(\"cAFe\");class o{constructor(e){f.default(20===e.length,\"Invalid address length\"),this.buf=e}static zero(){return new o(s.zeros(20))}static fromString(e){return f.default(u.isValidAddress(e),\"Invalid address\"),new o(s.toBuffer(e))}static fromPublicKey(t){f.default(e.isBuffer(t),\"Public key should be Buffer\");const r=u.pubToAddress(t);return new o(r)}static fromPrivateKey(t){f.default(e.isBuffer(t),\"Private key should be Buffer\");const r=u.privateToAddress(t);return new o(r)}static generate(t,r){return f.default(i.default.isBN(r)),new o(u.generateAddress(t.buf,r.toArrayLike(e)))}static generate2(t,r,n){return f.default(e.isBuffer(r)),f.default(e.isBuffer(n)),new o(u.generateAddress2(t.buf,r,n))}equals(e){return this.buf.equals(e.buf)}isZero(){return this.equals(o.zero())}isPrecompileOrSystemAddress(){const e=new i.default(this.buf),t=new i.default(0),r=new i.default(\"ffff\",\"hex\");return e.gte(t)&&e.lte(r)}toString(){return\"0x\"+this.buf.toString(\"hex\")}toBuffer(){return e.from(this.buf)}}t.Address=o}).call(this,r(\"HDXh\").Buffer)},ypah:function(e,t,r){\"use strict\";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,\"__esModule\",{value:!0}),t.KECCAK256_RLP=t.KECCAK256_RLP_S=t.KECCAK256_RLP_ARRAY=t.KECCAK256_RLP_ARRAY_S=t.KECCAK256_NULL=t.KECCAK256_NULL_S=t.TWO_POW256=t.MAX_INTEGER=void 0;const f=r(\"HDXh\").Buffer,i=n(r(\"OZ/i\"));t.MAX_INTEGER=new i.default(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",16),t.TWO_POW256=new i.default(\"10000000000000000000000000000000000000000000000000000000000000000\",16),t.KECCAK256_NULL_S=\"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\",t.KECCAK256_NULL=f.from(t.KECCAK256_NULL_S,\"hex\"),t.KECCAK256_RLP_ARRAY_S=\"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",t.KECCAK256_RLP_ARRAY=f.from(t.KECCAK256_RLP_ARRAY_S,\"hex\"),t.KECCAK256_RLP_S=\"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\",t.KECCAK256_RLP=f.from(t.KECCAK256_RLP_S,\"hex\")}}]);","map":{"version":3,"sources":["static/chunks/13f43c8747fe32cd0ce78954f63c870eccb968a6.60542d39ebd6aa9166d8.js"],"names":["window","push","6yEv","module","exports","__webpack_require__","Buffer","__createBinding","this","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","rlphash","ripemd160FromArray","ripemd160FromString","ripemd160","sha256FromArray","sha256FromString","sha256","keccakFromArray","keccakFromHexString","keccakFromString","keccak256","keccak","keccak_1","createHash","rlp","bytes_1","helpers_1","a","bits","assertIsBuffer","keccak224","keccak384","keccak512","Error","assertIsString","buf","from","assertIsHexString","toBuffer","assertIsArray","_sha256","update","digest","_ripemd160","padded","hash","setLengthLeft","encode","BNs3","__importDefault","default","toType","TypeOutput","bnToRlp","bnToHex","bn_js_1","ethjs_util_1","toString","unpadBuffer","toArrayLike","input","outputType","isHexString","Number","isSafeInteger","BN","bn","max","MAX_SAFE_INTEGER","gt","toNumber","L9Jt","defineProperties","assert_1","ethjsUtil","self","fields","data","raw","_fields","toJSON","label","obj","forEach","field","baToJSON","serialize","i","getter","setter","allowZero","allocUnsafe","allowLess","length","name","configurable","set","alias","stripHexPrefix","isBuffer","decode","Array","isArray","d","keys","indexOf","QMmI","addHexPrefix","toUnsigned","fromSigned","bufferToHex","bufferToInt","unpadHexString","unpadArray","setLengthRight","zeros","bytes","fill","setLength","msg","right","copy","slice","stripZeros","first","Uint8Array","padToEven","intToBuffer","isBN","toArray","num","fromTwos","toTwos","str","isHexPrefixed","ba","array","RD56","cAFe","isZeroAddress","zeroAddress","importPublic","privateToAddress","privateToPublic","publicToAddress","pubToAddress","isValidPublic","isValidPrivate","generateAddress2","generateAddress","isValidChecksumAddress","toChecksumAddress","isValidAddress","Account","secp256k1_1","constants_1","hash_1","types_1","[object Object]","nonce","balance","stateRoot","KECCAK256_RLP","codeHash","KECCAK256_NULL","_validate","accountData","serialized","values","fromValuesArray","lt","equals","isZero","hexAddress","e","test","eip1191ChainId","address","toLowerCase","prefix","ret","parseInt","toUpperCase","nonceBN","salt","initCode","concat","privateKey","privateKeyVerify","publicKey","sanitize","publicKeyVerify","pubKey","publicKeyConvert","publicKeyCreate","addr","g4Pk","sboa","hashPersonalMessage","isValidSignature","fromRpcSig","toRpcSig","ecrecover","ecsign","calculateSigRecovery","chainId","vBN","subn","chainIdBN","sub","muln","addn","isValidSigRecovery","recovery","rec","eqn","msgHash","signature","recid","ecdsaSign","r","s","senderPubKey","ecdsaRecover","sig","homesteadOrLater","SECP256K1_N_DIV_2","SECP256K1_N","rBN","sBN","cmp","message","tnHP","__exportStar","p","v0P2","Address","account_1","zero","addressBN","rangeMin","rangeMax","gte","lte","ypah","KECCAK256_RLP_S","KECCAK256_RLP_ARRAY","KECCAK256_RLP_ARRAY_S","KECCAK256_NULL_S","TWO_POW256","MAX_INTEGER"],"mappings":"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"},"name":"static/chunks/13f43c8747fe32cd0ce78954f63c870eccb968a6.60542d39ebd6aa9166d8.js","input":"(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[10],{\n\n/***/ \"6yEv\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;\nconst keccak_1 = __webpack_require__(\"wzGL\");\nconst createHash = __webpack_require__(\"mObS\");\nconst rlp = __importStar(__webpack_require__(\"o8pB\"));\nconst bytes_1 = __webpack_require__(\"QMmI\");\nconst helpers_1 = __webpack_require__(\"RD56\");\n/**\n * Creates Keccak hash of a Buffer input\n * @param a The input data (Buffer)\n * @param bits (number = 256) The Keccak width\n */\nexports.keccak = function (a, bits = 256) {\n    helpers_1.assertIsBuffer(a);\n    switch (bits) {\n        case 224: {\n            return keccak_1.keccak224(a);\n        }\n        case 256: {\n            return keccak_1.keccak256(a);\n        }\n        case 384: {\n            return keccak_1.keccak384(a);\n        }\n        case 512: {\n            return keccak_1.keccak512(a);\n        }\n        default: {\n            throw new Error(`Invald algorithm: keccak${bits}`);\n        }\n    }\n};\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer)\n */\nexports.keccak256 = function (a) {\n    return exports.keccak(a);\n};\n/**\n * Creates Keccak hash of a utf-8 string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */\nexports.keccakFromString = function (a, bits = 256) {\n    helpers_1.assertIsString(a);\n    const buf = Buffer.from(a, 'utf8');\n    return exports.keccak(buf, bits);\n};\n/**\n * Creates Keccak hash of an 0x-prefixed string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */\nexports.keccakFromHexString = function (a, bits = 256) {\n    helpers_1.assertIsHexString(a);\n    return exports.keccak(bytes_1.toBuffer(a), bits);\n};\n/**\n * Creates Keccak hash of a number array input\n * @param a The input data (number[])\n * @param bits (number = 256) The Keccak width\n */\nexports.keccakFromArray = function (a, bits = 256) {\n    helpers_1.assertIsArray(a);\n    return exports.keccak(bytes_1.toBuffer(a), bits);\n};\n/**\n * Creates SHA256 hash of an input.\n * @param  a The input data (Buffer|Array|String)\n */\nconst _sha256 = function (a) {\n    a = bytes_1.toBuffer(a);\n    return createHash('sha256').update(a).digest();\n};\n/**\n * Creates SHA256 hash of a Buffer input.\n * @param a The input data (Buffer)\n */\nexports.sha256 = function (a) {\n    helpers_1.assertIsBuffer(a);\n    return _sha256(a);\n};\n/**\n * Creates SHA256 hash of a string input.\n * @param a The input data (string)\n */\nexports.sha256FromString = function (a) {\n    helpers_1.assertIsString(a);\n    return _sha256(a);\n};\n/**\n * Creates SHA256 hash of a number[] input.\n * @param a The input data (number[])\n */\nexports.sha256FromArray = function (a) {\n    helpers_1.assertIsArray(a);\n    return _sha256(a);\n};\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */\nconst _ripemd160 = function (a, padded) {\n    a = bytes_1.toBuffer(a);\n    const hash = createHash('rmd160').update(a).digest();\n    if (padded === true) {\n        return bytes_1.setLengthLeft(hash, 32);\n    }\n    else {\n        return hash;\n    }\n};\n/**\n * Creates RIPEMD160 hash of a Buffer input.\n * @param a The input data (Buffer)\n * @param padded Whether it should be padded to 256 bits or not\n */\nexports.ripemd160 = function (a, padded) {\n    helpers_1.assertIsBuffer(a);\n    return _ripemd160(a, padded);\n};\n/**\n * Creates RIPEMD160 hash of a string input.\n * @param a The input data (String)\n * @param padded Whether it should be padded to 256 bits or not\n */\nexports.ripemd160FromString = function (a, padded) {\n    helpers_1.assertIsString(a);\n    return _ripemd160(a, padded);\n};\n/**\n * Creates RIPEMD160 hash of a number[] input.\n * @param a The input data (number[])\n * @param padded Whether it should be padded to 256 bits or not\n */\nexports.ripemd160FromArray = function (a, padded) {\n    helpers_1.assertIsArray(a);\n    return _ripemd160(a, padded);\n};\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */\nexports.rlphash = function (a) {\n    return exports.keccak(rlp.encode(a));\n};\n//# sourceMappingURL=hash.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"HDXh\").Buffer))\n\n/***/ }),\n\n/***/ \"BNs3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToHex = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(\"OZ/i\"));\nconst ethjs_util_1 = __webpack_require__(\"mhLr\");\nconst bytes_1 = __webpack_require__(\"QMmI\");\n/**\n * Convert BN to 0x-prefixed hex string.\n */\nfunction bnToHex(value) {\n    return `0x${value.toString(16)}`;\n}\nexports.bnToHex = bnToHex;\n/**\n * Convert value from BN to RLP (unpadded buffer)\n * @param value value to convert\n */\nfunction bnToRlp(value) {\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n    // for compatibility with browserify and similar tools\n    return bytes_1.unpadBuffer(value.toArrayLike(Buffer));\n}\nexports.bnToRlp = bnToRlp;\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\n/**\n * Convert an input to a specified type\n * @param input value to convert\n * @param outputType type to output\n */\nfunction toType(input, outputType) {\n    if (typeof input === 'string' && !ethjs_util_1.isHexString(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    }\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n    }\n    input = bytes_1.toBuffer(input);\n    if (outputType === TypeOutput.Buffer) {\n        return input;\n    }\n    else if (outputType === TypeOutput.BN) {\n        return new bn_js_1.default(input);\n    }\n    else if (outputType === TypeOutput.Number) {\n        const bn = new bn_js_1.default(input);\n        const max = new bn_js_1.default(Number.MAX_SAFE_INTEGER.toString());\n        if (bn.gt(max)) {\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n        }\n        return bn.toNumber();\n    }\n    else {\n        // outputType === TypeOutput.PrefixedHexString\n        return `0x${input.toString('hex')}`;\n    }\n}\nexports.toType = toType;\n//# sourceMappingURL=types.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"HDXh\").Buffer))\n\n/***/ }),\n\n/***/ \"L9Jt\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defineProperties = void 0;\nconst assert_1 = __importDefault(__webpack_require__(\"7rlJ\"));\nconst ethjsUtil = __importStar(__webpack_require__(\"mhLr\"));\nconst rlp = __importStar(__webpack_require__(\"o8pB\"));\nconst bytes_1 = __webpack_require__(\"QMmI\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */\nexports.defineProperties = function (self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function (label = false) {\n        if (label) {\n            const obj = {};\n            self._fields.forEach((field) => {\n                obj[field] = `0x${self[field].toString('hex')}`;\n            });\n            return obj;\n        }\n        return bytes_1.baToJSON(self.raw);\n    };\n    self.serialize = function serialize() {\n        return rlp.encode(self.raw);\n    };\n    fields.forEach((field, i) => {\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = bytes_1.toBuffer(v);\n            if (v.toString('hex') === '00' && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = bytes_1.unpadBuffer(v);\n                assert_1.default(field.length >= v.length, `The field ${field.name} must not have more ${field.length} bytes`);\n            }\n            else if (!(field.allowZero && v.length === 0) && field.length) {\n                assert_1.default(field.length === v.length, `The field ${field.name} must have byte length of ${field.length}`);\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter,\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter,\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === 'string') {\n            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');\n        }\n        if (Buffer.isBuffer(data)) {\n            data = rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error('wrong number of fields in data');\n            }\n            // make sure all the items are buffers\n            data.forEach((d, i) => {\n                self[self._fields[i]] = bytes_1.toBuffer(d);\n            });\n        }\n        else if (typeof data === 'object') {\n            const keys = Object.keys(data);\n            fields.forEach((field) => {\n                if (keys.indexOf(field.name) !== -1)\n                    self[field.name] = data[field.name];\n                if (keys.indexOf(field.alias) !== -1)\n                    self[field.alias] = data[field.alias];\n            });\n        }\n        else {\n            throw new Error('invalid data');\n        }\n    }\n};\n//# sourceMappingURL=object.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"HDXh\").Buffer))\n\n/***/ }),\n\n/***/ \"QMmI\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(\"OZ/i\"));\nconst ethjs_util_1 = __webpack_require__(\"mhLr\");\nconst helpers_1 = __webpack_require__(\"RD56\");\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */\nexports.zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */\nconst setLength = function (msg, length, right) {\n    const buf = exports.zeros(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    }\n    else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nexports.setLengthLeft = function (msg, length) {\n    helpers_1.assertIsBuffer(msg);\n    return setLength(msg, length, false);\n};\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nexports.setLengthRight = function (msg, length) {\n    helpers_1.assertIsBuffer(msg);\n    return setLength(msg, length, true);\n};\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */\nconst stripZeros = function (a) {\n    let first = a[0];\n    while (a.length > 0 && first.toString() === '0') {\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */\nexports.unpadBuffer = function (a) {\n    helpers_1.assertIsBuffer(a);\n    return stripZeros(a);\n};\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */\nexports.unpadArray = function (a) {\n    helpers_1.assertIsArray(a);\n    return stripZeros(a);\n};\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */\nexports.unpadHexString = function (a) {\n    helpers_1.assertIsHexString(a);\n    a = ethjs_util_1.stripHexPrefix(a);\n    return stripZeros(a);\n};\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */\nexports.toBuffer = function (v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === 'string') {\n        if (!ethjs_util_1.isHexString(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from(ethjs_util_1.padToEven(ethjs_util_1.stripHexPrefix(v)), 'hex');\n    }\n    if (typeof v === 'number') {\n        return ethjs_util_1.intToBuffer(v);\n    }\n    if (bn_js_1.default.isBN(v)) {\n        return v.toArrayLike(Buffer);\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error('invalid type');\n};\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */\nexports.bufferToInt = function (buf) {\n    return new bn_js_1.default(exports.toBuffer(buf)).toNumber();\n};\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */\nexports.bufferToHex = function (buf) {\n    buf = exports.toBuffer(buf);\n    return '0x' + buf.toString('hex');\n};\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */\nexports.fromSigned = function (num) {\n    return new bn_js_1.default(num).fromTwos(256);\n};\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */\nexports.toUnsigned = function (num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */\nexports.addHexPrefix = function (str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return ethjs_util_1.isHexPrefixed(str) ? str : '0x' + str;\n};\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */\nexports.baToJSON = function (ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString('hex')}`;\n    }\n    else if (ba instanceof Array) {\n        const array = [];\n        for (let i = 0; i < ba.length; i++) {\n            array.push(exports.baToJSON(ba[i]));\n        }\n        return array;\n    }\n};\n//# sourceMappingURL=bytes.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"HDXh\").Buffer))\n\n/***/ }),\n\n/***/ \"RD56\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst ethjs_util_1 = __webpack_require__(\"mhLr\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */\nexports.assertIsHexString = function (input) {\n    if (!ethjs_util_1.isHexString(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */\nexports.assertIsBuffer = function (input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */\nexports.assertIsArray = function (input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */\nexports.assertIsString = function (input) {\n    if (typeof input !== 'string') {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\n//# sourceMappingURL=helpers.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"HDXh\").Buffer))\n\n/***/ }),\n\n/***/ \"cAFe\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst assert_1 = __importDefault(__webpack_require__(\"7rlJ\"));\nconst bn_js_1 = __importDefault(__webpack_require__(\"OZ/i\"));\nconst rlp = __importStar(__webpack_require__(\"o8pB\"));\nconst secp256k1_1 = __webpack_require__(\"IhPl\");\nconst ethjs_util_1 = __webpack_require__(\"mhLr\");\nconst constants_1 = __webpack_require__(\"ypah\");\nconst bytes_1 = __webpack_require__(\"QMmI\");\nconst hash_1 = __webpack_require__(\"6yEv\");\nconst helpers_1 = __webpack_require__(\"RD56\");\nconst types_1 = __webpack_require__(\"BNs3\");\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    constructor(nonce = new bn_js_1.default(0), balance = new bn_js_1.default(0), stateRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, stateRoot, codeHash } = accountData;\n        return new Account(nonce ? new bn_js_1.default(bytes_1.toBuffer(nonce)) : undefined, balance ? new bn_js_1.default(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, stateRoot, codeHash] = values;\n        return new Account(new bn_js_1.default(nonce), new bn_js_1.default(balance), stateRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce.lt(new bn_js_1.default(0))) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance.lt(new bn_js_1.default(0))) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error('stateRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    raw() {\n        return [types_1.bnToRlp(this.nonce), types_1.bnToRlp(this.balance), this.stateRoot, this.codeHash];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    serialize() {\n        return rlp.encode(this.raw());\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    isEmpty() {\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (hexAddress) {\n    try {\n        helpers_1.assertIsString(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    helpers_1.assertIsHexString(hexAddress);\n    const address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();\n    let prefix = '';\n    if (eip1191ChainId) {\n        const chainId = types_1.toType(eip1191ChainId, types_1.TypeOutput.BN);\n        prefix = chainId.toString() + '0x';\n    }\n    const hash = hash_1.keccakFromString(prefix + address).toString('hex');\n    let ret = '0x';\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n    helpers_1.assertIsBuffer(from);\n    helpers_1.assertIsBuffer(nonce);\n    const nonceBN = new bn_js_1.default(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return hash_1.rlphash([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n    helpers_1.assertIsBuffer(from);\n    helpers_1.assertIsBuffer(salt);\n    helpers_1.assertIsBuffer(initCode);\n    assert_1.default(from.length === 20);\n    assert_1.default(salt.length === 32);\n    const address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));\n    return address.slice(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n    return secp256k1_1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize = false) {\n    helpers_1.assertIsBuffer(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1_1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return secp256k1_1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize = false) {\n    helpers_1.assertIsBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.publicKeyConvert(pubKey, false).slice(1));\n    }\n    assert_1.default(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n    helpers_1.assertIsBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.publicKeyCreate(privateKey, false)).slice(1);\n};\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n    helpers_1.assertIsBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.publicKeyConvert(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\n/**\n * Returns the zero address.\n */\nexports.zeroAddress = function () {\n    const addressLength = 20;\n    const addr = bytes_1.zeros(addressLength);\n    return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\nexports.isZeroAddress = function (hexAddress) {\n    try {\n        helpers_1.assertIsString(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    const zeroAddr = exports.zeroAddress();\n    return zeroAddr === hexAddress;\n};\n//# sourceMappingURL=account.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"HDXh\").Buffer))\n\n/***/ }),\n\n/***/ \"g4Pk\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Re-exports commonly used modules:\n * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rlp = exports.BN = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(\"OZ/i\"));\nexports.BN = bn_js_1.default;\nconst rlp = __importStar(__webpack_require__(\"o8pB\"));\nexports.rlp = rlp;\n//# sourceMappingURL=externals.js.map\n\n/***/ }),\n\n/***/ \"sboa\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst secp256k1_1 = __webpack_require__(\"IhPl\");\nconst bn_js_1 = __importDefault(__webpack_require__(\"OZ/i\"));\nconst bytes_1 = __webpack_require__(\"QMmI\");\nconst hash_1 = __webpack_require__(\"6yEv\");\nconst helpers_1 = __webpack_require__(\"RD56\");\nconst types_1 = __webpack_require__(\"BNs3\");\nfunction ecsign(msgHash, privateKey, chainId) {\n    const { signature, recid: recovery } = secp256k1_1.ecdsaSign(msgHash, privateKey);\n    const r = Buffer.from(signature.slice(0, 32));\n    const s = Buffer.from(signature.slice(32, 64));\n    if (!chainId || typeof chainId === 'number') {\n        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)\n        if (chainId && !Number.isSafeInteger(chainId)) {\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n        }\n        const v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;\n        return { r, s, v };\n    }\n    const chainIdBN = types_1.toType(chainId, types_1.TypeOutput.BN);\n    const v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);\n    return { r, s, v };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    const vBN = types_1.toType(v, types_1.TypeOutput.BN);\n    if (!chainId) {\n        return vBN.subn(27);\n    }\n    const chainIdBN = types_1.toType(chainId, types_1.TypeOutput.BN);\n    return vBN.sub(chainIdBN.muln(2).addn(35));\n}\nfunction isValidSigRecovery(recovery) {\n    const rec = new bn_js_1.default(recovery);\n    return rec.eqn(0) || rec.eqn(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * @returns Recovered public key\n */\nexports.ecrecover = function (msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32)], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    const senderPubKey = secp256k1_1.ecdsaRecover(signature, recovery.toNumber(), msgHash);\n    return Buffer.from(secp256k1_1.publicKeyConvert(senderPubKey, false).slice(1));\n};\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * @returns Signature\n */\nexports.toRpcSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));\n};\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n */\nexports.fromRpcSig = function (sig) {\n    const buf = bytes_1.toBuffer(sig);\n    if (buf.length < 65) {\n        throw new Error('Invalid signature length');\n    }\n    let v = bytes_1.bufferToInt(buf.slice(64));\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v: v,\n        r: buf.slice(0, 32),\n        s: buf.slice(32, 64),\n    };\n};\n/**\n * Validate a ECDSA signature.\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexports.isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {\n    const SECP256K1_N_DIV_2 = new bn_js_1.default('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n    const SECP256K1_N = new bn_js_1.default('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBN = new bn_js_1.default(r);\n    const sBN = new bn_js_1.default(s);\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexports.hashPersonalMessage = function (message) {\n    helpers_1.assertIsBuffer(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length.toString()}`, 'utf-8');\n    return hash_1.keccak(Buffer.concat([prefix, message]));\n};\n//# sourceMappingURL=signature.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"HDXh\").Buffer))\n\n/***/ }),\n\n/***/ \"tnHP\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference path=\"./@types/ethjs-util/index.ts\"/>\n/**\n * Constants\n */\n__exportStar(__webpack_require__(\"ypah\"), exports);\n/**\n * Account class and helper functions\n */\n__exportStar(__webpack_require__(\"cAFe\"), exports);\n/**\n * Address type\n */\n__exportStar(__webpack_require__(\"v0P2\"), exports);\n/**\n * Hash functions\n */\n__exportStar(__webpack_require__(\"6yEv\"), exports);\n/**\n * ECDSA signature\n */\n__exportStar(__webpack_require__(\"sboa\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */\n__exportStar(__webpack_require__(\"QMmI\"), exports);\n/**\n * Function for definining properties on an object\n */\n__exportStar(__webpack_require__(\"L9Jt\"), exports);\n/**\n * External exports (BN, rlp, secp256k1)\n */\n__exportStar(__webpack_require__(\"g4Pk\"), exports);\n/**\n * Helpful TypeScript types\n */\n__exportStar(__webpack_require__(\"BNs3\"), exports);\n/**\n * Export ethjs-util methods\n */\n__exportStar(__webpack_require__(\"mhLr\"), exports);\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"v0P2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nconst assert_1 = __importDefault(__webpack_require__(\"7rlJ\"));\nconst bn_js_1 = __importDefault(__webpack_require__(\"OZ/i\"));\nconst bytes_1 = __webpack_require__(\"QMmI\");\nconst account_1 = __webpack_require__(\"cAFe\");\nclass Address {\n    constructor(buf) {\n        assert_1.default(buf.length === 20, 'Invalid address length');\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    static zero() {\n        return new Address(bytes_1.zeros(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    static fromString(str) {\n        assert_1.default(account_1.isValidAddress(str), 'Invalid address');\n        return new Address(bytes_1.toBuffer(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    static fromPublicKey(pubKey) {\n        assert_1.default(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n        const buf = account_1.pubToAddress(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    static fromPrivateKey(privateKey) {\n        assert_1.default(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n        const buf = account_1.privateToAddress(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    static generate(from, nonce) {\n        assert_1.default(bn_js_1.default.isBN(nonce));\n        return new Address(account_1.generateAddress(from.buf, nonce.toArrayLike(Buffer)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    static generate2(from, salt, initCode) {\n        assert_1.default(Buffer.isBuffer(salt));\n        assert_1.default(Buffer.isBuffer(initCode));\n        return new Address(account_1.generateAddress2(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */\n    equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */\n    isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */\n    isPrecompileOrSystemAddress() {\n        const addressBN = new bn_js_1.default(this.buf);\n        const rangeMin = new bn_js_1.default(0);\n        const rangeMax = new bn_js_1.default('ffff', 'hex');\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n    }\n    /**\n     * Returns hex encoding of address.\n     */\n    toString() {\n        return '0x' + this.buf.toString('hex');\n    }\n    /**\n     * Returns Buffer representation of address.\n     */\n    toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address;\n//# sourceMappingURL=address.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"HDXh\").Buffer))\n\n/***/ }),\n\n/***/ \"ypah\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;\nconst Buffer = __webpack_require__(\"HDXh\").Buffer;\nconst bn_js_1 = __importDefault(__webpack_require__(\"OZ/i\"));\n/**\n * The max integer that this VM can handle\n */\nexports.MAX_INTEGER = new bn_js_1.default('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\n/**\n * 2^256\n */\nexports.TWO_POW256 = new bn_js_1.default('10000000000000000000000000000000000000000000000000000000000000000', 16);\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n//# sourceMappingURL=constants.js.map\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/hash.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/types.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/object.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/bytes.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/helpers.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/account.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/externals.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/signature.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/index.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/address.js","/home/paulo/Desktop/Private_Blockchain/Web/WebApp/node_modules/ethereumjs-util/dist/constants.js"],"names":[],"mappings":";;;;;;AAAA,8CAAa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,yCAAyC,6BAA6B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,MAA8B;AACvD,mBAAmB,mBAAO,CAAC,MAAa;AACxC,yBAAyB,mBAAO,CAAC,MAAK;AACtC,gBAAgB,mBAAO,CAAC,MAAS;AACjC,kBAAkB,mBAAO,CAAC,MAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;ACxKA,8CAAa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA,gCAAgC,mBAAO,CAAC,MAAO;AAC/C,qBAAqB,mBAAO,CAAC,MAAY;AACzC,gBAAgB,mBAAO,CAAC,MAAS;AACjC;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6DAA6D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,MAAM;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,iC;;;;;;;;;ACrEA,8CAAa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,yCAAyC,6BAA6B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA,iCAAiC,mBAAO,CAAC,MAAQ;AACjD,+BAA+B,mBAAO,CAAC,MAAY;AACnD,yBAAyB,mBAAO,CAAC,MAAK;AACtC,gBAAgB,mBAAO,CAAC,MAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4BAA4B;AAC9D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,WAAW,sBAAsB,aAAa;AACtH;AACA;AACA,yEAAyE,WAAW,4BAA4B,aAAa;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;AC9HA,8CAAa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA,gCAAgC,mBAAO,CAAC,MAAO;AAC/C,qBAAqB,mBAAO,CAAC,MAAY;AACzC,kBAAkB,mBAAO,CAAC,MAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0IAA0I,EAAE;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;ACrMA,8CAAa;AACb,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,MAAY;AACzC;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,wFAAwF,MAAM;AAC9F;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,8EAA8E,MAAM;AACpF;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,wEAAwE,MAAM;AAC9E;AACA;AACA;AACA,mC;;;;;;;;;AC5CA,8CAAa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,yCAAyC,6BAA6B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA,iCAAiC,mBAAO,CAAC,MAAQ;AACjD,gCAAgC,mBAAO,CAAC,MAAO;AAC/C,yBAAyB,mBAAO,CAAC,MAAK;AACtC,oBAAoB,mBAAO,CAAC,MAAiC;AAC7D,qBAAqB,mBAAO,CAAC,MAAY;AACzC,oBAAoB,mBAAO,CAAC,MAAa;AACzC,gBAAgB,mBAAO,CAAC,MAAS;AACjC,eAAe,mBAAO,CAAC,MAAQ;AAC/B,kBAAkB,mBAAO,CAAC,MAAW;AACrC,gBAAgB,mBAAO,CAAC,MAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAsC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;AChRa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,yCAAyC,6BAA6B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA,gCAAgC,mBAAO,CAAC,MAAO;AAC/C;AACA,yBAAyB,mBAAO,CAAC,MAAK;AACtC;AACA,qC;;;;;;;;AClCA,8CAAa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA,oBAAoB,mBAAO,CAAC,MAAiC;AAC7D,gCAAgC,mBAAO,CAAC,MAAO;AAC/C,gBAAgB,mBAAO,CAAC,MAAS;AACjC,eAAe,mBAAO,CAAC,MAAQ;AAC/B,kBAAkB,mBAAO,CAAC,MAAW;AACrC,gBAAgB,mBAAO,CAAC,MAAS;AACjC;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,0BAA0B;AAC5F;AACA;AACA,qC;;;;;;;;;ACxHa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAa;AAClC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAW;AAChC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAW;AAChC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAQ;AAC7B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAa;AAClC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAS;AAC9B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAU;AAC/B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAa;AAClC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAS;AAC9B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,MAAY;AACjC,iC;;;;;;;;ACrDA,8CAAa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA,iCAAiC,mBAAO,CAAC,MAAQ;AACjD,gCAAgC,mBAAO,CAAC,MAAO;AAC/C,gBAAgB,mBAAO,CAAC,MAAS;AACjC,kBAAkB,mBAAO,CAAC,MAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;ACvGa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,MAAQ;AAC/B,gCAAgC,mBAAO,CAAC,MAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC","file":"x","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst createHash = require('create-hash');\nconst rlp = __importStar(require(\"rlp\"));\nconst bytes_1 = require(\"./bytes\");\nconst helpers_1 = require(\"./helpers\");\n/**\n * Creates Keccak hash of a Buffer input\n * @param a The input data (Buffer)\n * @param bits (number = 256) The Keccak width\n */\nexports.keccak = function (a, bits = 256) {\n    helpers_1.assertIsBuffer(a);\n    switch (bits) {\n        case 224: {\n            return keccak_1.keccak224(a);\n        }\n        case 256: {\n            return keccak_1.keccak256(a);\n        }\n        case 384: {\n            return keccak_1.keccak384(a);\n        }\n        case 512: {\n            return keccak_1.keccak512(a);\n        }\n        default: {\n            throw new Error(`Invald algorithm: keccak${bits}`);\n        }\n    }\n};\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer)\n */\nexports.keccak256 = function (a) {\n    return exports.keccak(a);\n};\n/**\n * Creates Keccak hash of a utf-8 string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */\nexports.keccakFromString = function (a, bits = 256) {\n    helpers_1.assertIsString(a);\n    const buf = Buffer.from(a, 'utf8');\n    return exports.keccak(buf, bits);\n};\n/**\n * Creates Keccak hash of an 0x-prefixed string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */\nexports.keccakFromHexString = function (a, bits = 256) {\n    helpers_1.assertIsHexString(a);\n    return exports.keccak(bytes_1.toBuffer(a), bits);\n};\n/**\n * Creates Keccak hash of a number array input\n * @param a The input data (number[])\n * @param bits (number = 256) The Keccak width\n */\nexports.keccakFromArray = function (a, bits = 256) {\n    helpers_1.assertIsArray(a);\n    return exports.keccak(bytes_1.toBuffer(a), bits);\n};\n/**\n * Creates SHA256 hash of an input.\n * @param  a The input data (Buffer|Array|String)\n */\nconst _sha256 = function (a) {\n    a = bytes_1.toBuffer(a);\n    return createHash('sha256').update(a).digest();\n};\n/**\n * Creates SHA256 hash of a Buffer input.\n * @param a The input data (Buffer)\n */\nexports.sha256 = function (a) {\n    helpers_1.assertIsBuffer(a);\n    return _sha256(a);\n};\n/**\n * Creates SHA256 hash of a string input.\n * @param a The input data (string)\n */\nexports.sha256FromString = function (a) {\n    helpers_1.assertIsString(a);\n    return _sha256(a);\n};\n/**\n * Creates SHA256 hash of a number[] input.\n * @param a The input data (number[])\n */\nexports.sha256FromArray = function (a) {\n    helpers_1.assertIsArray(a);\n    return _sha256(a);\n};\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */\nconst _ripemd160 = function (a, padded) {\n    a = bytes_1.toBuffer(a);\n    const hash = createHash('rmd160').update(a).digest();\n    if (padded === true) {\n        return bytes_1.setLengthLeft(hash, 32);\n    }\n    else {\n        return hash;\n    }\n};\n/**\n * Creates RIPEMD160 hash of a Buffer input.\n * @param a The input data (Buffer)\n * @param padded Whether it should be padded to 256 bits or not\n */\nexports.ripemd160 = function (a, padded) {\n    helpers_1.assertIsBuffer(a);\n    return _ripemd160(a, padded);\n};\n/**\n * Creates RIPEMD160 hash of a string input.\n * @param a The input data (String)\n * @param padded Whether it should be padded to 256 bits or not\n */\nexports.ripemd160FromString = function (a, padded) {\n    helpers_1.assertIsString(a);\n    return _ripemd160(a, padded);\n};\n/**\n * Creates RIPEMD160 hash of a number[] input.\n * @param a The input data (number[])\n * @param padded Whether it should be padded to 256 bits or not\n */\nexports.ripemd160FromArray = function (a, padded) {\n    helpers_1.assertIsArray(a);\n    return _ripemd160(a, padded);\n};\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */\nexports.rlphash = function (a) {\n    return exports.keccak(rlp.encode(a));\n};\n//# sourceMappingURL=hash.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToHex = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst ethjs_util_1 = require(\"ethjs-util\");\nconst bytes_1 = require(\"./bytes\");\n/**\n * Convert BN to 0x-prefixed hex string.\n */\nfunction bnToHex(value) {\n    return `0x${value.toString(16)}`;\n}\nexports.bnToHex = bnToHex;\n/**\n * Convert value from BN to RLP (unpadded buffer)\n * @param value value to convert\n */\nfunction bnToRlp(value) {\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n    // for compatibility with browserify and similar tools\n    return bytes_1.unpadBuffer(value.toArrayLike(Buffer));\n}\nexports.bnToRlp = bnToRlp;\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\n/**\n * Convert an input to a specified type\n * @param input value to convert\n * @param outputType type to output\n */\nfunction toType(input, outputType) {\n    if (typeof input === 'string' && !ethjs_util_1.isHexString(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    }\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n    }\n    input = bytes_1.toBuffer(input);\n    if (outputType === TypeOutput.Buffer) {\n        return input;\n    }\n    else if (outputType === TypeOutput.BN) {\n        return new bn_js_1.default(input);\n    }\n    else if (outputType === TypeOutput.Number) {\n        const bn = new bn_js_1.default(input);\n        const max = new bn_js_1.default(Number.MAX_SAFE_INTEGER.toString());\n        if (bn.gt(max)) {\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n        }\n        return bn.toNumber();\n    }\n    else {\n        // outputType === TypeOutput.PrefixedHexString\n        return `0x${input.toString('hex')}`;\n    }\n}\nexports.toType = toType;\n//# sourceMappingURL=types.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defineProperties = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst ethjsUtil = __importStar(require(\"ethjs-util\"));\nconst rlp = __importStar(require(\"rlp\"));\nconst bytes_1 = require(\"./bytes\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */\nexports.defineProperties = function (self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function (label = false) {\n        if (label) {\n            const obj = {};\n            self._fields.forEach((field) => {\n                obj[field] = `0x${self[field].toString('hex')}`;\n            });\n            return obj;\n        }\n        return bytes_1.baToJSON(self.raw);\n    };\n    self.serialize = function serialize() {\n        return rlp.encode(self.raw);\n    };\n    fields.forEach((field, i) => {\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = bytes_1.toBuffer(v);\n            if (v.toString('hex') === '00' && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = bytes_1.unpadBuffer(v);\n                assert_1.default(field.length >= v.length, `The field ${field.name} must not have more ${field.length} bytes`);\n            }\n            else if (!(field.allowZero && v.length === 0) && field.length) {\n                assert_1.default(field.length === v.length, `The field ${field.name} must have byte length of ${field.length}`);\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter,\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter,\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === 'string') {\n            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');\n        }\n        if (Buffer.isBuffer(data)) {\n            data = rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error('wrong number of fields in data');\n            }\n            // make sure all the items are buffers\n            data.forEach((d, i) => {\n                self[self._fields[i]] = bytes_1.toBuffer(d);\n            });\n        }\n        else if (typeof data === 'object') {\n            const keys = Object.keys(data);\n            fields.forEach((field) => {\n                if (keys.indexOf(field.name) !== -1)\n                    self[field.name] = data[field.name];\n                if (keys.indexOf(field.alias) !== -1)\n                    self[field.alias] = data[field.alias];\n            });\n        }\n        else {\n            throw new Error('invalid data');\n        }\n    }\n};\n//# sourceMappingURL=object.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst ethjs_util_1 = require(\"ethjs-util\");\nconst helpers_1 = require(\"./helpers\");\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */\nexports.zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */\nconst setLength = function (msg, length, right) {\n    const buf = exports.zeros(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    }\n    else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nexports.setLengthLeft = function (msg, length) {\n    helpers_1.assertIsBuffer(msg);\n    return setLength(msg, length, false);\n};\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nexports.setLengthRight = function (msg, length) {\n    helpers_1.assertIsBuffer(msg);\n    return setLength(msg, length, true);\n};\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */\nconst stripZeros = function (a) {\n    let first = a[0];\n    while (a.length > 0 && first.toString() === '0') {\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */\nexports.unpadBuffer = function (a) {\n    helpers_1.assertIsBuffer(a);\n    return stripZeros(a);\n};\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */\nexports.unpadArray = function (a) {\n    helpers_1.assertIsArray(a);\n    return stripZeros(a);\n};\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */\nexports.unpadHexString = function (a) {\n    helpers_1.assertIsHexString(a);\n    a = ethjs_util_1.stripHexPrefix(a);\n    return stripZeros(a);\n};\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */\nexports.toBuffer = function (v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === 'string') {\n        if (!ethjs_util_1.isHexString(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from(ethjs_util_1.padToEven(ethjs_util_1.stripHexPrefix(v)), 'hex');\n    }\n    if (typeof v === 'number') {\n        return ethjs_util_1.intToBuffer(v);\n    }\n    if (bn_js_1.default.isBN(v)) {\n        return v.toArrayLike(Buffer);\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error('invalid type');\n};\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */\nexports.bufferToInt = function (buf) {\n    return new bn_js_1.default(exports.toBuffer(buf)).toNumber();\n};\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */\nexports.bufferToHex = function (buf) {\n    buf = exports.toBuffer(buf);\n    return '0x' + buf.toString('hex');\n};\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */\nexports.fromSigned = function (num) {\n    return new bn_js_1.default(num).fromTwos(256);\n};\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */\nexports.toUnsigned = function (num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */\nexports.addHexPrefix = function (str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return ethjs_util_1.isHexPrefixed(str) ? str : '0x' + str;\n};\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */\nexports.baToJSON = function (ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString('hex')}`;\n    }\n    else if (ba instanceof Array) {\n        const array = [];\n        for (let i = 0; i < ba.length; i++) {\n            array.push(exports.baToJSON(ba[i]));\n        }\n        return array;\n    }\n};\n//# sourceMappingURL=bytes.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst ethjs_util_1 = require(\"ethjs-util\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */\nexports.assertIsHexString = function (input) {\n    if (!ethjs_util_1.isHexString(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */\nexports.assertIsBuffer = function (input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */\nexports.assertIsArray = function (input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */\nexports.assertIsString = function (input) {\n    if (typeof input !== 'string') {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\n//# sourceMappingURL=helpers.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst rlp = __importStar(require(\"rlp\"));\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst ethjs_util_1 = require(\"ethjs-util\");\nconst constants_1 = require(\"./constants\");\nconst bytes_1 = require(\"./bytes\");\nconst hash_1 = require(\"./hash\");\nconst helpers_1 = require(\"./helpers\");\nconst types_1 = require(\"./types\");\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    constructor(nonce = new bn_js_1.default(0), balance = new bn_js_1.default(0), stateRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, stateRoot, codeHash } = accountData;\n        return new Account(nonce ? new bn_js_1.default(bytes_1.toBuffer(nonce)) : undefined, balance ? new bn_js_1.default(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, stateRoot, codeHash] = values;\n        return new Account(new bn_js_1.default(nonce), new bn_js_1.default(balance), stateRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce.lt(new bn_js_1.default(0))) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance.lt(new bn_js_1.default(0))) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error('stateRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    raw() {\n        return [types_1.bnToRlp(this.nonce), types_1.bnToRlp(this.balance), this.stateRoot, this.codeHash];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    serialize() {\n        return rlp.encode(this.raw());\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    isEmpty() {\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (hexAddress) {\n    try {\n        helpers_1.assertIsString(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    helpers_1.assertIsHexString(hexAddress);\n    const address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();\n    let prefix = '';\n    if (eip1191ChainId) {\n        const chainId = types_1.toType(eip1191ChainId, types_1.TypeOutput.BN);\n        prefix = chainId.toString() + '0x';\n    }\n    const hash = hash_1.keccakFromString(prefix + address).toString('hex');\n    let ret = '0x';\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n    helpers_1.assertIsBuffer(from);\n    helpers_1.assertIsBuffer(nonce);\n    const nonceBN = new bn_js_1.default(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return hash_1.rlphash([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n    helpers_1.assertIsBuffer(from);\n    helpers_1.assertIsBuffer(salt);\n    helpers_1.assertIsBuffer(initCode);\n    assert_1.default(from.length === 20);\n    assert_1.default(salt.length === 32);\n    const address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));\n    return address.slice(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n    return secp256k1_1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize = false) {\n    helpers_1.assertIsBuffer(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1_1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return secp256k1_1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize = false) {\n    helpers_1.assertIsBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.publicKeyConvert(pubKey, false).slice(1));\n    }\n    assert_1.default(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n    helpers_1.assertIsBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.publicKeyCreate(privateKey, false)).slice(1);\n};\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n    helpers_1.assertIsBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.publicKeyConvert(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\n/**\n * Returns the zero address.\n */\nexports.zeroAddress = function () {\n    const addressLength = 20;\n    const addr = bytes_1.zeros(addressLength);\n    return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\nexports.isZeroAddress = function (hexAddress) {\n    try {\n        helpers_1.assertIsString(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    const zeroAddr = exports.zeroAddress();\n    return zeroAddr === hexAddress;\n};\n//# sourceMappingURL=account.js.map","\"use strict\";\n/**\n * Re-exports commonly used modules:\n * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rlp = exports.BN = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nexports.BN = bn_js_1.default;\nconst rlp = __importStar(require(\"rlp\"));\nexports.rlp = rlp;\n//# sourceMappingURL=externals.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst bytes_1 = require(\"./bytes\");\nconst hash_1 = require(\"./hash\");\nconst helpers_1 = require(\"./helpers\");\nconst types_1 = require(\"./types\");\nfunction ecsign(msgHash, privateKey, chainId) {\n    const { signature, recid: recovery } = secp256k1_1.ecdsaSign(msgHash, privateKey);\n    const r = Buffer.from(signature.slice(0, 32));\n    const s = Buffer.from(signature.slice(32, 64));\n    if (!chainId || typeof chainId === 'number') {\n        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)\n        if (chainId && !Number.isSafeInteger(chainId)) {\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n        }\n        const v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;\n        return { r, s, v };\n    }\n    const chainIdBN = types_1.toType(chainId, types_1.TypeOutput.BN);\n    const v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);\n    return { r, s, v };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    const vBN = types_1.toType(v, types_1.TypeOutput.BN);\n    if (!chainId) {\n        return vBN.subn(27);\n    }\n    const chainIdBN = types_1.toType(chainId, types_1.TypeOutput.BN);\n    return vBN.sub(chainIdBN.muln(2).addn(35));\n}\nfunction isValidSigRecovery(recovery) {\n    const rec = new bn_js_1.default(recovery);\n    return rec.eqn(0) || rec.eqn(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * @returns Recovered public key\n */\nexports.ecrecover = function (msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32)], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    const senderPubKey = secp256k1_1.ecdsaRecover(signature, recovery.toNumber(), msgHash);\n    return Buffer.from(secp256k1_1.publicKeyConvert(senderPubKey, false).slice(1));\n};\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * @returns Signature\n */\nexports.toRpcSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));\n};\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n */\nexports.fromRpcSig = function (sig) {\n    const buf = bytes_1.toBuffer(sig);\n    if (buf.length < 65) {\n        throw new Error('Invalid signature length');\n    }\n    let v = bytes_1.bufferToInt(buf.slice(64));\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v: v,\n        r: buf.slice(0, 32),\n        s: buf.slice(32, 64),\n    };\n};\n/**\n * Validate a ECDSA signature.\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexports.isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {\n    const SECP256K1_N_DIV_2 = new bn_js_1.default('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n    const SECP256K1_N = new bn_js_1.default('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBN = new bn_js_1.default(r);\n    const sBN = new bn_js_1.default(s);\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexports.hashPersonalMessage = function (message) {\n    helpers_1.assertIsBuffer(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length.toString()}`, 'utf-8');\n    return hash_1.keccak(Buffer.concat([prefix, message]));\n};\n//# sourceMappingURL=signature.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference path=\"./@types/ethjs-util/index.ts\"/>\n/**\n * Constants\n */\n__exportStar(require(\"./constants\"), exports);\n/**\n * Account class and helper functions\n */\n__exportStar(require(\"./account\"), exports);\n/**\n * Address type\n */\n__exportStar(require(\"./address\"), exports);\n/**\n * Hash functions\n */\n__exportStar(require(\"./hash\"), exports);\n/**\n * ECDSA signature\n */\n__exportStar(require(\"./signature\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */\n__exportStar(require(\"./bytes\"), exports);\n/**\n * Function for definining properties on an object\n */\n__exportStar(require(\"./object\"), exports);\n/**\n * External exports (BN, rlp, secp256k1)\n */\n__exportStar(require(\"./externals\"), exports);\n/**\n * Helpful TypeScript types\n */\n__exportStar(require(\"./types\"), exports);\n/**\n * Export ethjs-util methods\n */\n__exportStar(require(\"ethjs-util\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst bytes_1 = require(\"./bytes\");\nconst account_1 = require(\"./account\");\nclass Address {\n    constructor(buf) {\n        assert_1.default(buf.length === 20, 'Invalid address length');\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    static zero() {\n        return new Address(bytes_1.zeros(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    static fromString(str) {\n        assert_1.default(account_1.isValidAddress(str), 'Invalid address');\n        return new Address(bytes_1.toBuffer(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    static fromPublicKey(pubKey) {\n        assert_1.default(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n        const buf = account_1.pubToAddress(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    static fromPrivateKey(privateKey) {\n        assert_1.default(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n        const buf = account_1.privateToAddress(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    static generate(from, nonce) {\n        assert_1.default(bn_js_1.default.isBN(nonce));\n        return new Address(account_1.generateAddress(from.buf, nonce.toArrayLike(Buffer)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    static generate2(from, salt, initCode) {\n        assert_1.default(Buffer.isBuffer(salt));\n        assert_1.default(Buffer.isBuffer(initCode));\n        return new Address(account_1.generateAddress2(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */\n    equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */\n    isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */\n    isPrecompileOrSystemAddress() {\n        const addressBN = new bn_js_1.default(this.buf);\n        const rangeMin = new bn_js_1.default(0);\n        const rangeMax = new bn_js_1.default('ffff', 'hex');\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n    }\n    /**\n     * Returns hex encoding of address.\n     */\n    toString() {\n        return '0x' + this.buf.toString('hex');\n    }\n    /**\n     * Returns Buffer representation of address.\n     */\n    toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address;\n//# sourceMappingURL=address.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;\nconst Buffer = require('buffer').Buffer;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n/**\n * The max integer that this VM can handle\n */\nexports.MAX_INTEGER = new bn_js_1.default('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\n/**\n * 2^256\n */\nexports.TWO_POW256 = new bn_js_1.default('10000000000000000000000000000000000000000000000000000000000000000', 16);\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n//# sourceMappingURL=constants.js.map"]}}